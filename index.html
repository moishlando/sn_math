<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SN Monospace Math (Inline)</title>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; background:#1e1e1e; color:#f5f5f5; }
    .cm-editor { height: 100vh; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .cm-content { caret-color: #fff; }
    .katex-widget { background:#2b2b2b; padding:2px 4px; border-radius:4px; cursor:pointer; display:inline-block; }
    .bold-mark { font-weight:700; color:#ffd966; } /* inner bold highlight */
    /* optional: mute the literal ** markers visually (still present in text model) */
    .asterisk-mute { opacity: 0.4; }
  </style>
</head>
<body>

<div id="mount"></div>

<script type="module">
  // --- Imports (ESM via CDN) ---
  import {EditorState}        from "https://esm.sh/@codemirror/state@6";
  import {EditorView, keymap, Decoration, WidgetType, ViewPlugin, ViewUpdate} 
                              from "https://esm.sh/@codemirror/view@6";
  import {defaultKeymap, history, historyKeymap} 
                              from "https://esm.sh/@codemirror/commands@6";
  import {indentWithTab}      from "https://esm.sh/@codemirror/commands@6";

  // ---------- Math Decoration (KaTeX) ----------
  class KaTeXWidget extends WidgetType {
    constructor(tex, display) {
      super(); this.tex = tex; this.display = display;
    }
    eq(other) { return other.tex === this.tex && other.display === this.display; }
    toDOM() {
      const span = document.createElement("span");
      span.className = "katex-widget";
      try {
        span.innerHTML = katex.renderToString(this.tex, {displayMode: this.display, throwOnError:false});
      } catch { span.textContent = this.tex; }
      // clicking the widget should place the caret inside the underlying $...$
      span.addEventListener("mousedown", (e) => { e.preventDefault(); });
      return span;
    }
    ignoreEvent() { return false; }
  }

  // Scan doc for $$...$$ (can be multiline) and $...$ (single line), build decorations.
  function mathDecorations(view) {
    const decos = [];
    const sel = view.state.selection.main;
    const doc = view.state.doc;
    const text = doc.toString();

    // helper to check if selection intersects [from, to)
    const intersects = (from, to) => !(sel.to <= from || sel.from >= to);

    // 1) block math $$...$$ (allow newlines)
    {
      const reBlock = /\$\$([\s\S]*?)\$\$/g;  // greedy across lines
      let m;
      while ((m = reBlock.exec(text)) !== null) {
        const from = m.index, to = m.index + m[0].length;
        if (intersects(from, to)) continue; // skip rendering when caret inside â†’ keep raw for editing
        const tex = m[1];
        const deco = Decoration.widget({
          widget: new KaTeXWidget(tex, true),
          side: 0
        }).range(from);
        // hide the raw text by covering it with a widget and adding a zero-width placeholder after
        decos.push(deco, Decoration.replace({}).range(from, to));
      }
    }

    // 2) inline math $...$ (no newlines inside)
    {
      const reInline = /\$(?:\\\$|[^\n$])+\$/g;
      let m;
      while ((m = reInline.exec(text)) !== null) {
        const raw = m[0];
        // ignore $$...$$ which block regex already handled (starts/ends with $$)
        if (raw.startsWith("$$") || raw.endsWith("$$")) continue;
        const from = m.index, to = m.index + raw.length;
        if (intersects(from, to)) continue;
        const tex = raw.slice(1, -1);
        const deco = Decoration.widget({
          widget: new KaTeXWidget(tex, false),
          side: 0
        }).range(from);
        decos.push(deco, Decoration.replace({}).range(from, to));
      }
    }

    // 3) **bold** inner highlight (optional)
    {
      const reBold = /\*\*([^\n*][\s\S]*?[^\n*])\*\*/g;
      let m;
      while ((m = reBold.exec(text)) !== null) {
        const fullFrom = m.index, fullTo = m.index + m[0].length;
        if (intersects(fullFrom, fullTo)) continue; // editable raw when caret inside
        const innerFrom = fullFrom + 2, innerTo = fullTo - 2;
        decos.push(Decoration.mark({class: "bold-mark"}).range(innerFrom, innerTo));
        // (Optional) visually mute the literal ** markers:
        // decos.push(Decoration.mark({class:"asterisk-mute"}).range(fullFrom, innerFrom));
        // decos.push(Decoration.mark({class:"asterisk-mute"}).range(innerTo, fullTo));
      }
    }

    return Decoration.set(decos, true);
  }

  const mathPlugin = ViewPlugin.fromClass(class {
    constructor(view) { this.decos = mathDecorations(view); }
    update(update) {
      if (update.docChanged || update.selectionSet) {
        this.decos = mathDecorations(update.view);
      }
    }
  }, { decorations: v => v.decos });

  // ---------- SN sync ----------
  function postToSN(view) {
    const text = view.state.doc.toString();
    window.parent.postMessage({ action: "set-text", text }, "*");
  }

  // Debounce helper (limits SN messages)
  function debounce(fn, ms) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }
  const debouncedPost = debounce(postToSN, 120);

  // Notify SN on content changes
  const snSyncPlugin = ViewPlugin.fromClass(class{
    update(u) { if (u.docChanged) debouncedPost(u.view); }
  });

  // ---------- Editor Init ----------
  const startText = "Monospace notes.\nBold with **stars**.\nInline $x^2+y^2=z^2$ and block:\n$$E=mc^2$$\nClick rendered math to place the caret and edit; it will auto-render when the $...$ is balanced.";
  const state = EditorState.create({
    doc: startText,
    extensions: [
      history(),
      keymap.of([...defaultKeymap, ...historyKeymap, indentWithTab]),
      EditorView.lineWrapping,
      mathPlugin,
      snSyncPlugin
    ]
  });

  const view = new EditorView({ state, parent: document.getElementById("mount") });

  // Receive content from Standard Notes
  window.addEventListener("message", (e) => {
    if (e.data?.action === "set-text") {
      const text = e.data.text ?? "";
      if (text === view.state.doc.toString()) return;
      view.dispatch({
        changes: { from: 0, to: view.state.doc.length, insert: text }
      });
    }
  });

  // Send initial content to SN once (so the note shows something if new)
  postToSN(view);

  // Clicking a KaTeX widget should move caret inside the underlying math
  document.addEventListener("mousedown", (ev) => {
    const w = ev.target.closest(".katex-widget");
    if (!w) return;
    // Find the position of the widget by DOM -> pos mapping
    const pos = view.posAtDOM(w, 0);
    // Place caret just after the opening $, which is pos in the model
    // We search backward to the next '$' before this pos (safe fallback: pos)
    const docStr = view.state.doc.toString();
    let from = docStr.lastIndexOf("$", pos);
    if (from >= 0 && docStr[from-1] === "$") from--; // handle $$
    if (from < 0) from = pos;
    view.dispatch({ selection: { anchor: from + 1 } }); // inside the dollars
    ev.preventDefault();
  });
</script>

</body>
</html>
