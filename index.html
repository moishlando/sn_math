<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SN Monospace Math (Inline, No Flicker)</title>

  <!-- CodeMirror 5 (UMD) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5/lib/codemirror.css">
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5/lib/codemirror.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5/addon/selection/mark-selection.js"></script>

  <!-- KaTeX (UMD) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#1e1e1e; }
    .CodeMirror {
      height: 100vh;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      color: #f5f5f5;
      background: #1e1e1e;
    }
    /* rendered KaTeX container */
    .katex-chip {
      display: inline-block;
      background:#2b2b2b;
      border-radius:4px;
      padding:2px 4px;
      cursor: pointer;
    }
    /* bold highlight for **text** (the inner part) */
    .bold-inner { font-weight:700; color:#ffd966; }
    /* optionally dim the literal ** markers */
    .bold-marker { opacity:0.4; }
  </style>
</head>
<body>
  <textarea id="seed" style="display:none;">Monospace notes.
Bold with **stars**. Inline math: $x^2+y^2=z^2$
Block math:
$$
E=mc^2
$$

Click a rendered formula to edit; it re-renders when the $…$ is balanced.
</textarea>
  <div id="host"></div>

<script>
(function(){
  // --- Editor init ---
  const host = document.getElementById('host');
  const cm = CodeMirror(host, {
    value: document.getElementById('seed').value,
    lineNumbers: false,
    lineWrapping: true,
    tabindex: 0
  });

  // Track current marks so we can clear/reapply without flicker
  let mathMarks = [];
  let boldMarks = [];

  function clearMarks(arr) {
    for (const m of arr) m.clear();
    arr.length = 0;
  }

  function posFromIndex(idx) { return cm.posFromIndex(idx); }
  function indexFromPos(pos) { return cm.indexFromPos(pos); }

  function selectionIntersects(fromIdx, toIdx) {
    const ranges = cm.listSelections();
    for (const r of ranges) {
      const a = indexFromPos(r.anchor);
      const b = indexFromPos(r.head);
      const lo = Math.min(a,b), hi = Math.max(a,b);
      if (!(hi <= fromIdx || lo >= toIdx)) return true;
    }
    return false;
  }

  function renderDecorations() {
    const text = cm.getValue();
    clearMarks(mathMarks);
    clearMarks(boldMarks);

    // --- Math: $$...$$ (multiline) ---
    const reBlock = /\$\$([\s\S]*?)\$\$/g;
    let m;
    while ((m = reBlock.exec(text)) !== null) {
      const from = m.index;
      const to   = m.index + m[0].length;
      if (selectionIntersects(from, to)) continue; // keep raw while editing

      const expr = m[1];
      const fromPos = posFromIndex(from);
      const toPos   = posFromIndex(to);

      // Build widget
      const span = document.createElement('span');
      span.className = 'katex-chip';
      try {
        span.innerHTML = katex.renderToString(expr, {displayMode:true, throwOnError:false});
      } catch (_) {
        span.textContent = expr;
      }
      // Clicking on widget clears the mark → restores raw $$...$$ for editing
      span.addEventListener('mousedown', (ev) => {
        ev.preventDefault();
        // clear the mark by finding it via coords
        for (const mk of mathMarks) {
          const r = mk.find();
          if (!r) continue;
          if (CodeMirror.cmpPos(r.from, fromPos)===0 && CodeMirror.cmpPos(r.to, toPos)===0) {
            mk.clear();
            cm.focus();
            // place caret just after opening $$ (from + 2)
            cm.setCursor(posFromIndex(from + 2));
            break;
          }
        }
      });

      const mk = cm.markText(fromPos, toPos, {
        replacedWith: span,
        handleMouseEvents: true,
        atomic: true,       // keep it as a single unit until user clicks
        inclusiveLeft: false,
        inclusiveRight: false
      });
      mathMarks.push(mk);
    }

    // --- Math: $...$ (single line, no newline inside) ---
    const reInline = /\$(?:\\\$|[^\n$])+\$/g;
    while ((m = reInline.exec(text)) !== null) {
      const raw = m[0];
      if (raw.startsWith('$$') || raw.endsWith('$$')) continue; // handled above
      const from = m.index;
      const to   = m.index + raw.length;
      if (selectionIntersects(from, to)) continue;

      const expr = raw.slice(1, -1);
      const fromPos = posFromIndex(from);
      const toPos   = posFromIndex(to);

      const span = document.createElement('span');
      span.className = 'katex-chip';
      try {
        span.innerHTML = katex.renderToString(expr, {displayMode:false, throwOnError:false});
      } catch (_) {
        span.textContent = expr;
      }
      span.addEventListener('mousedown', (ev) => {
        ev.preventDefault();
        for (const mk of mathMarks) {
          const r = mk.find();
          if (!r) continue;
          if (CodeMirror.cmpPos(r.from, fromPos)===0 && CodeMirror.cmpPos(r.to, toPos)===0) {
            mk.clear();
            cm.focus();
            cm.setCursor(posFromIndex(from + 1)); // after opening $
            break;
          }
        }
      });

      const mk = cm.markText(fromPos, toPos, {
        replacedWith: span,
        handleMouseEvents: true,
        atomic: true,
        inclusiveLeft: false,
        inclusiveRight: false
      });
      mathMarks.push(mk);
    }

    // --- Bold: **inner** highlight (keep raw visible/editable when cursor inside) ---
    const reBold = /\*\*([^\n*][\s\S]*?[^\n*])\*\*/g;
    while ((m = reBold.exec(text)) !== null) {
      const fullFrom = m.index;
      const fullTo   = m.index + m[0].length;
      const innerFrom = fullFrom + 2, innerTo = fullTo - 2;

      if (selectionIntersects(fullFrom, fullTo)) continue; // editable raw while cursor inside

      // mark inner as bold
      boldMarks.push(cm.markText(posFromIndex(innerFrom), posFromIndex(innerTo), {
        className: 'bold-inner',
        inclusiveLeft: false,
        inclusiveRight: false
      }));

      // (optional) dim markers **
      // boldMarks.push(cm.markText(posFromIndex(fullFrom), posFromIndex(innerFrom), {className:'bold-marker'}));
      // boldMarks.push(cm.markText(posFromIndex(innerTo), posFromIndex(fullTo),   {className:'bold-marker'}));
    }

    // sync to Standard Notes (raw text)
    debouncedSyncToSN();
  }

  // --- Re-render on changes & on cursor moves (so editing zones stay raw) ---
  cm.on('changes', renderDecorations);
  cm.on('cursorActivity', renderDecorations);

  // --- SN integration ---
  const debouncedSyncToSN = debounce(() => {
    window.parent.postMessage({ action: 'set-text', text: cm.getValue() }, '*');
  }, 120);

  window.addEventListener('message', (e) => {
    if (e.data && e.data.action === 'set-text') {
      const incoming = e.data.text || '';
      if (incoming !== cm.getValue()) {
        const cur = cm.getCursor();
        cm.setValue(incoming);
        cm.setCursor(cur);
      }
      renderDecorations();
    }
  });

  // util: debounce
  function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

  // initial paint
  renderDecorations();

})();
</script>
</body>
</html>
