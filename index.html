<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Math Editor</title>

  <!-- CodeMirror CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.css" />

  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

  <!-- SN theme variables -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sn-extension-api/dist/sn.min.css">

  <style>
    body {
      margin: 0;
      font-family: var(--sn-stylekit-editor-font-family, monospace);
      font-size: var(--sn-stylekit-font-size-editor, 14px);
      background-color: var(--sn-stylekit-background-color, white);
      color: var(--sn-stylekit-foreground-color, black);
    }

    .CodeMirror {
      height: calc(100vh - 40px);
      font-family: var(--sn-stylekit-editor-font-family, monospace);
      font-size: var(--sn-stylekit-font-size-editor, 14px);
      color: var(--sn-stylekit-foreground-color, black);
    }

    .toolbar {
      height: 40px;
      background: var(--sn-stylekit-contrast-background-color, #ddd);
      border-bottom: 1px solid var(--sn-stylekit-border-color, #ccc);
      display: flex;
      align-items: center;
      padding: 0 8px;
    }

    .toolbar button {
      font-size: 13px;
      padding: 4px 8px;
      border: 1px solid var(--sn-stylekit-border-color, #aaa);
      border-radius: 4px;
      background: var(--sn-stylekit-background-color, white);
      color: var(--sn-stylekit-foreground-color, black);
      cursor: pointer;
    }

    .katex-chip {
      padding: 0 2px;
      background: none;
      border-radius: 0;
      font-size: var(--sn-stylekit-font-size-editor, 14px);
      color: var(--sn-stylekit-foreground-color, black);
    }

    .bold-inner {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="toggle-math">Toggle Math Rendering</button>
  </div>
  <div id="host"></div>

  <!-- CodeMirror JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.js"></script>

  <!-- KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

  <!-- Standard Notes Component Relay -->
  <script src="https://cdn.jsdelivr.net/npm/@standardnotes/component-relay/dist/dist.js"></script>

  <script>
  (function(){
    const host = document.getElementById('host');
    const cm = CodeMirror(host, {
      value: "",
      lineWrapping: true,
      viewportMargin: Infinity,
      mode: null
    });

    let mathMarks = [], boldMarks = [];
    let renderMath = true; // toggle flag

    function clearMarks(arr){ for(const m of arr) m.clear(); arr.length=0; }
    function posFromIndex(i){ return cm.posFromIndex(i); }
    function indexFromPos(p){ return cm.indexFromPos(p); }
    function selectionIntersects(from,to){
      for(const r of cm.listSelections()){
        const a=indexFromPos(r.anchor), b=indexFromPos(r.head);
        if(!(Math.max(a,b)<=from || Math.min(a,b)>=to)) return true;
      } return false;
    }

    function renderDecorations(){
      const text = cm.getValue();
      clearMarks(mathMarks); clearMarks(boldMarks);

      // only render math if toggle is on
      if(renderMath){
        // block math $$...$$
        const reBlock=/\$\$([\s\S]*?)\$\$/g; let m;
        while((m=reBlock.exec(text))){
          const from=m.index, to=from+m[0].length;
          if(selectionIntersects(from,to)) continue;
          const span=document.createElement("span"); span.className="katex-chip";
          try { span.innerHTML=katex.renderToString(m[1],{displayMode:true,throwOnError:false}); }
          catch{ span.textContent=m[1]; }
          const mk=cm.markText(posFromIndex(from),posFromIndex(to),{replacedWith:span,atomic:true});
          span.addEventListener("mousedown",e=>{e.preventDefault();mk.clear();cm.focus();cm.setCursor(posFromIndex(from+2));});
          mathMarks.push(mk);
        }

        // inline math $...$
        const reInline=/\$(?:\\\$|[^\n$])+\$/g;
        while((m=reInline.exec(text))){
          const raw=m[0]; if(raw.startsWith("$$")||raw.endsWith("$$")) continue;
          const from=m.index, to=from+raw.length;
          if(selectionIntersects(from,to)) continue;
          const expr=raw.slice(1,-1);
          const span=document.createElement("span"); span.className="katex-chip";
          try { span.innerHTML=katex.renderToString(expr,{throwOnError:false}); }
          catch{ span.textContent=expr; }
          const mk=cm.markText(posFromIndex(from),posFromIndex(to),{replacedWith:span,atomic:true});
          span.addEventListener("mousedown",e=>{e.preventDefault();mk.clear();cm.focus();cm.setCursor(posFromIndex(from+1));});
          mathMarks.push(mk);
        }
      }

      // TeX bold: \textbf{...}
      const reBold=/\\textbf\{([^}]*)\}/g;
      let m;
      while((m=reBold.exec(text))){
        const from=m.index, to=from+m[0].length;
        if(selectionIntersects(from,to)) continue;
        const innerFrom=from + "\\textbf{".length;
        const innerTo=to - 1;
        boldMarks.push(cm.markText(posFromIndex(innerFrom),posFromIndex(innerTo),{className:"bold-inner"}));
      }

      // Headings: \chapter{}, \section{}, \subsection{}, \subsubsection{}, \paragraph{}, with or without *
      const reHeading=/\\(chapter|section|subsection|subsubsection|paragraph)\*?\{([^}]*)\}/g;
      while((m=reHeading.exec(text))){
        const from=m.index, to=from+m[0].length;
        if(selectionIntersects(from,to)) continue;
        const cmdLen=m[0].indexOf("{")+1;
        const innerFrom=from+cmdLen;
        const innerTo=to-1;
        boldMarks.push(cm.markText(posFromIndex(innerFrom),posFromIndex(innerTo),{className:"bold-inner"}));
      }
    }

    // --- SN Component Relay ---
    const debounce=(fn,ms)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);};};
    let currentNote;

    const relay=new window.ComponentRelay({
      targetWindow: window,
      options:{coallesedSaving:true, coallesedSavingDelay:350}
    });

    relay.streamContextItem((note)=>{
      currentNote=note;
      if(note.isMetadataUpdate) return;
      const incoming=(note.content && note.content.text)||"";
      if(incoming!==cm.getValue()) cm.setValue(incoming);
      const locked=relay.getItemAppDataValue(note,'locked');
      cm.setOption('readOnly',locked?'nocursor':false);
      renderDecorations();
    });

    const saveNow=debounce(()=>{
      if(!currentNote) return;
      const raw=cm.getValue();
      relay.saveItemWithPresave(currentNote,()=>{
        currentNote.content.text=raw;
        currentNote.content.preview_plain=raw.slice(0,100);
      });
    },300);

    cm.on("changes",()=>{renderDecorations();saveNow();});
    cm.on("cursorActivity",renderDecorations);

    // Toggle button
    document.getElementById("toggle-math").addEventListener("click",()=>{
      renderMath=!renderMath;
      renderDecorations();
    });
  })();
  </script>
</body>
</html>
